---
layout: post
title: "bash脚本内部变量"
subtitle: ""
date: 2016-04-14
author: Fengya
category: shell
tags: shell linux mac
finished: true
---

# bash脚本内部变量

## $BASH

bash的程序文件的路径，如/bin/bash

## $BASH_ENV

该环境变量保存一个Bash启动文件路径，当启动一个脚本程序时会去读该环境变量指定的文件。

例如可以设置

`export BASH_ENV=./testScript`

这里testScript的内容为

```shell
#!/bin/bash
echo $BASH_ENV
echo "Hello world!"
```

相当于我们每次运行一个bash脚本的时候都会去引用一下testScript这个文件。

运行的结果为：

`Hello world!`
`./testScript`

`Hello world!`
`./testScript`
相当于首先引用了一次testScript，打印出了前两行，然后执行testScript，打印出了后两行。我们可以利用这个变量引入一个文件来设置一些别名，设置一些常量之类。

## $BASH_SUBSHELL

一个指示子shell(subshell)等级的变量。它是Bash版本3新加入的。

例如运行一下脚本：

```shell
#!/bin/bash
echo $BASH_SUBSHELL
( echo $BASH_SUBSHELL )
```
输出内容为：

`0`

`1`

这里()用于使用子shell（subshell）来执行命令。

根据这个变量可以判断子shell等级，进行例如变量作用域判断之类的操作。

## $BASH_VERSINFO[n]

这个数组含有6个元素，指示了安装的Bash版本的信息。它和$BASH_VERSION相似，但它们还是有一些小小的不同。

```shell
# BASH_VERSINFO[0] = 3                      # 主版本号.
# BASH_VERSINFO[1] = 00                     # 次版本号.
# BASH_VERSINFO[2] = 14                     # 补丁级.
# BASH_VERSINFO[3] = 1                      # 编译版本.
# BASH_VERSINFO[4] = release                # 发行状态.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 结构体系
```
## $BASH_VERSION

安装在系统里的Bash版本

如运行

`echo $BASH_VERSION`

会得到

`3.2.57(1)-release`

## $DIRSTACK

在目录堆栈里面最顶端的值(它受[pushd](http://manual.51yip.com/shell/internal.html#PUSHDREF)和[popd](http://manual.51yip.com/shell/internal.html#POPDREF)的控制)

这个内建的变量和dirs命令相符，但dirs是给出整个目录堆栈的内容。

## $EDITOR

由脚本调用的默认的编辑器，一般是vi或是emacs。通常是没有设置的空变量。

## $EUID

有效用户id

## $FUNCNAME

当前函数的名字

例如运行以下bash脚本：

```shell
#!/bin/bash

function HelloWorld(){
  echo $FUNCNAME
}

echo $FUNCNAME
HelloWorld
```

得到的输出为：

` `

`HelloWorld`

第一行为空，第二行为函数名。

## $GLOBIGNORE

由通配符(globbing)扩展的一列文件名模式

## $GROUPS

目前用户所属的组

这是一个当前用户的group id的列表，记录在/etc/passwd和/etc/group中

## $HOME

用户的家目录

linux中如/home/username

mac中如/User/username

也即~表示的目录

## $HOSTNAME

在系统启动时由一个初始化脚本中用hostname命令给系统指派一个名字。

## $HOSTTYPE

机器类型

类似$MACHTYPE一样表示系统硬件

`echo $HOSTTYPE`

`x86_64`

## $IFS

内部字段分隔符，决定了bash如何分割字段，默认是空白符

运行脚本如下：
```shell
#!/bin/sh

function OutPutArgs(){
        for arg
        do
                echo "[$arg]"
        done
}

IFS=" "
var=" a  b c  "
OutPutArgs $var

IFS=":"
var="a::b:b:c"
OutPutArgs $var
```
结果如下：

```
[a]
[b]
[c]
[a]
[]
[b]
[b]
[c]
```

## $IGNOREEOF

忽略EOF，在控制台退出之前忽略所有的文件结尾标识

## $LC_COLLATE

它常常在.bashrc或/etc/profile文件里被设置，它控制文件名扩展和模式匹配的展开顺序。如果设置不当，LC_COLLATE会在文件名通配符(filename globbing)里引起不可预料的结果。

到Bash2.05版本止，文件名通配符不再区分在方括号里的字符串范围中的大小写了。例如，ls [A-M]*会匹配File1.txt和file1.txt。为了保持方括号区分大小写的惯例，在/etc/profile文件和/或在~/.bashrc文件里由命令export LC_COLLATE=C把LC_COLLATE环境变量设置成C可以达到目的。

## $LINENO

表示当前变量在shell脚本中的行数，可以用于调试shell脚本。

## $MACHTYPE

机器类型

如：

```
echo $MACHTYPE
x86_64-apple-darwin15
```

## $OLDPWD

上一次的工作目录，即运行`cd -`所到达的目录

## $OSTYPE

操作系统类型

如：

```
echo $OSTYPE
darwin15
```

## $PATH

可执行程序的搜索路径

当给出一个命令时，shell会自动在一个哈希表里搜索由PATH变量里所列的路径寻找该命令程序。$PATH变量被保存在环境变量里，是一串由冒号(:)分割的目录名的列表。通常，系统把此变量的值在/etc/profile文件和/或在~/.bashrc文件中被定义赋值。

PATH=${PATH}:/opt/bin 能把/opt/bin目录加到当前现有的目录列表中去。在一个脚本中，它可以用这种方法临时地加一个目录到目录列表中去。当一个脚本退出时，此变量会恢复回原先的$PATH值(子进程不能改变父进程的环境变量)。

保存在$PATH目录列表中的当前"工作目录"(./)通常因为会引发安全漏洞而被忽略。因此search path中通常没有工作目录。

```
echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

## $PIPESTATUS

此数组变量保存了最后执行的前台管道的退出状态。它不一定和最后执行的命令的退出状态一样。

$PIPESTATUS数组的成员保存了每一个在管道里执行的命令各自的退出状态。$PIPESTATUS[0]保存了管道里第一个命令的退出状态，$PIPESTATUS[1]保存了管道里第二个命令的退出状态，以此类推。

例如：

```
$ ls | aaa | wc
bash: aaa: command not found
       0       0       0
$ echo ${PIPESTATUS[@]}
141 127 0
```

## $PPID

一个进程的$PPID变量保存它的父进程的进程ID(pid)。

## $PROMPT_COMMAND

这个变量在主提示符前($PS1显示之前)执行它的值里保存的命令。

## $PS1

这是主提示符（第一提示符），它能在命令行上看见。即每次输入命令时前面的那些内容。

## $PS2

副提示符（第二提示符），它在期望有附加的输入时能看见。它显示像">"的提示。即如果输一条命令如

```
for i in a
```

然后回车。通常我们看见的是>符号。即PS2。

## $PS3

第三提示符。它在一个select循环里显示

例如运行以下脚本：

```shell
#!/bin/bash

PS3='Choose one:'

select vegetable in "beans" "carrots"
do
        echo "Your choose is ${vegetable}"
        break
done

exit 0
```

运行结果类似：

```
1) beans
2) carrots
Choose one:1
Your choose is beans
```



## $PS4

第四提示符，它在用-x选项调用一个脚本时的输出的每一行开头显示。它通常显示像"+"的提示。

## $PWD

工作目录。类似于内建命令pwd

## $REPLY

没有变量提供给read命令时的默认变量．这也适用于select命令的目录，但只是提供被选择的变量项目编号而不是变量本身的值

例如执行以下脚本：

```shell
#!/bin/bash

echo -n "Input a:"
read

echo "a is: $REPLY"

read -p "b is :" b

echo "b is: $b"
echo "REPLY is :$REPLY"
```

得到的结果如下：

```
Input a:a
a is: a
b is :b
b is: b
REPLY is :a
```

## $SECONDS

脚本已运行秒数

## $SHELLLOPTS

已经激活的shell选项列表，它是一个只读变量

## $SHLVL

SHELL的嵌套级别．指示了Bash被嵌套了多深．在命令行里，$SHLVL是1，因此在一个脚本里，它是2.

## $TMOUT

如果*$TMOUT*环境变量被设为非零值时间值*time*，那么经过*time*这么长的时间后，shell提示符会超时．这将使此shell退出登录．

在Bash版本2.05b以上，可以在脚本中把*$TMOUT*和[read](http://manual.51yip.com/shell/internal.html#READREF)命令结合使用

有其他更复杂的在脚本中实现定时输入的方法．另一个方法是设置一个定时循环，超时时给脚本发送一个信号．这个办法要求有一个处理例程来捕捉(trap)由定时循环产生的信号

## $UID

用户ID号

这是当前用户的用户标识号，它在/etc/passwd文件中记录。

这是当前用户的真实ID，即使只是临时通过su命令转换成另外一个用户也会显示成转换成的ID号。$UID是个只读变量，不能在命令行或是脚本中更改它，并且它和内建命令id是有些相似的。

## 位置参数

### $0, $1, $2,等等

位置参数由命令行传给脚本或传给一个函数，或设置(set)给一个变量

### $##

命令行参数[]或者是位置参数的数量

### $*

所有的位置参数都被当成单个单元。

"$*"必须被引号引起来

### $@

和$*相同，但每个参数都是一个引起的字符串。那是说，参数都是没有被解析或扩展，是完整无缺地被传递的。这是说在参数列表中的每一个参数都被看作是一个单独的单元。

"$@"应该被引号引起来。

## 其他特殊参数

### $!

在后台运行的最后一个作业的PID(进程ID)

```
$ echo aa & echo bb & echo $!
[1] 12875
[2] 12876
12876
```

### $_

保存前一个命令最后一个参数的变量值

例如：

```
$ echo a b c
a b c
echo $_
c
$ echo
$ echo $_
echo
```

### $?

一个命令，函数或脚本自身的退出状态码，可以用于在脚本里判断运行状况。

### $

脚本本身的进程PID。$$变量常被用于脚本中生成一个"唯一的"临时文件名. 这通常比调用mktemp还要简单。

## Locale

Locale是linux系统中多语言环境的设置接口，Locale根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。

Locale是linux系统中多语言环境的设置接口，Locale根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。
locale把按照所涉及到的文化传统的各个方面分成12个大类，这12个大类分别是：

1、语言符号及其分类(LC_CTYPE)
2、数字(LC_NUMERIC)
3、比较和排序习惯(LC_COLLATE)
4、时间显示格式(LC_TIME)
5、货币单位(LC_MONETARY)
6、信息主要是提示信息,错误信息,状态信息,标题,标签,按钮和菜单等(LC_MESSAGES)
7、姓名书写方式(LC_NAME)
8、地址书写方式(LC_ADDRESS)
9、电话号码书写方式(LC_TELEPHONE)
10、度量衡表达方式 (LC_MEASUREMENT)
11、默认纸张尺寸大小(LC_PAPER)
12、对locale自身包含信息的概述(LC_IDENTIFICATION)。

例如：

```
$ locale
LANG="zh_CN.UTF-8"
LC_COLLATE="zh_CN.UTF-8"
LC_CTYPE="zh_CN.UTF-8"
LC_MESSAGES="zh_CN.UTF-8"
LC_MONETARY="zh_CN.UTF-8"
LC_NUMERIC="zh_CN.UTF-8"
LC_TIME="zh_CN.UTF-8"
LC_ALL=
```

设定locale就是设定12大类的locale分类属性，即12个LC。除了这12个变量可以设定以外，为了简便起见，还有两个变量：LC_ALL和LANG。它们之间有一个优先级的关系：LC_ALL > LC >LANG。可以这么说，LC_ALL是最上级设定或者强制设定，而LANG是默认设定值。

